local func = require "autosig/func"
local coor = require "autosig/coor"
local pipe = require "autosig/pipe"
local streetutil = require "streetutil"
-- local dbg = require("LuaPanda")
-- local dump = require "luadump"

local math = math
local pi = math.pi
local abs = math.abs
local table = table
local unpack = table.unpack
local insert = table.insert

function data()
    return {
        type = "STREET_CONSTRUCTION",
        description = {
            name = _("MENU_NAME"),
            description = _("MENU_DESC")
        },
        availability = {
            yearFrom = 1800,
            yearTo = 1800
        },
        order = 2000,
        params = {},
        updateFn = function(params)
            local result = {
                edgeLists = {},
                models = {{
                    id = "asset/icon/marker_exclamation.mdl",
                    transf = coor.I(),
                }},
                groundFaces = {},
                edgeObjects = {}
            }
            
            local distance = params.distance

            local lengthList = pipe.new
                * params.edges
                * pipe.map(
                    function(e)
                        local f, t = unpack(e.edge)
                        -- local p0, v0 = unpack(f)
                        local p1, v1 = unpack(t)
                        return coor.xyz(unpack(v1)):length()
                    end)
                * pipe.fold(pipe.new / 0, function(acc, l) return acc / (acc[#acc] + l) end)
                * pipe.interlace()
            
            local totalLength = lengthList[#lengthList][2]
            
            local posF = {}
            for i, l in ipairs(lengthList) do
                local f, t = unpack(l)
                local pos = (#posF + 1) * distance
                local length = t - f
                local min = 0.3 / length
                min = min >= 0.005 and min or 0.005
                local max = 1 - min
                while pos > f and pos <= t do
                    local p = (pos - f) / length
                    if p >= max then p = max end
                    if p <= min then p = min end
                    insert(posF, {i, p})
                    pos = (#posF + 1) * distance
                end
            end
            
            local posB = {}
            for i = #lengthList, 1, -1 do
                local t, f = unpack(lengthList[i])
                f = totalLength - f
                t = totalLength - t
                local length = t - f
                local min = 0.3 / length
                min = min >= 0.005 and min or 0.005
                local max = 1 - min
                local pos = (#posB + 1) * distance
                while pos > f and pos <= t do
                    local p = 1 - (pos - f) / length
                    if p >= max then p = max end
                    if p <= min then p = min end
                    insert(posB, {i, p})
                    pos = (#posB + 1) * distance
                end
            end

            result.edgeLists =
                pipe.new * params.edges *
                pipe.map(function(e)
                    return
                        {
                            type = "TRACK",
                            edgeType = ({nil, "BRIDGE", "TUNNEL"})[e.edgeType],
                            edgeTypeName = ({nil, params.bridge .. ".lua", "railroad_old.lua"})[e.edgeType],
                            alignTerrain = true,
                            params = {
                                type = ({"high_speed.lua", "standard.lua"})[e.trackType],
                                catenary = e.catenary,
                            },
                            edges = e.edge,
                            snapNodes = e.snap0 and e.snap1 and {0, 1} or e.snap0 and {0} or e.snap1 and {1} or {},
                            freeNodes = params.isFinal and {0, 1} or {},
                        }
                end)
                
            if (params.isFinal) then
                result.edgeObjects =
                    pipe.new
                    * func.map(params.side ~= 2 and posB or {},
                        function(pos)
                            local e, p = unpack(pos)
                            return {
                                edge = e - 1,
                                param = p,
                                left = true,
                                model = params.signal .. ".mdl"
                            }
                        end)
                    + func.map(params.side ~= 1 and posF or {},
                        function(pos)
                            local e, p = unpack(pos)
                            return {
                                edge = e - 1,
                                param = p,
                                left = false,
                                model = params.signal .. ".mdl"
                            }
                        end)
            end
            
            return result
        end
    }
end
